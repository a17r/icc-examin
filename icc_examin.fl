# data file for the Fltk User Interface Designer (fluid)
version 1.0104 
header_name {.h} 
code_name {.cxx}
decl {\#define DEBUG} {public
} 

decl {\#include <stdio.h>} {public
} 

decl {\#include <iostream>} {public
} 

decl {//\#include <sstream>} {public
} 

decl {\#include <cassert>} {public
} 

decl {\#include <FL/Fl.H>} {public
} 

decl {\#include <FL/Fl_Window.H>} {public
} 

decl {\#include <FL/Fl_Menu_Bar.H>} {public
} 

decl {\#include <FL/Fl_Box.H>} {public
} 

decl {\#include <FL/Fl_File_Chooser.H> 
\#include <FLU/Flu_File_Chooser.h> 
\#include <FL/Fl_Hold_Browser.H> 
\#include <FL/Fl_File_Icon.H> 
\#include <FL/Fl_Shared_Image.H> 
\#include <FL/Fl_PNM_Image.H>} {public
} 

decl {char *statlabel;
 std::string filename_alt;
 bool setTitleUrl = true;

 int px,py,pw,ph;
 int fullscreen;
  int inspekt_topline;
 int tag_nummer;} {} 

decl {class TagDrawings;
class TagBrowser;
class TagTexts;
class MftChoice;
class GL_Ansicht;} {public
} 

decl {\#define _(text) text} {public
} 

decl {\#define status(_texte) {std::stringstream s; s << _texte; stat->label(s.str().c_str());}} {public
} 

decl {\#include "icc_draw.h"} {} 

decl {\#include "icc_profile.h"
\#include "icc_utils.h"
\#include "icc_profilierer.h"
\#include "icc_ueber.h"} {public
} 

decl {\#include "agviewer.h"
\#include "icc_gl.h"} {} 

decl {ICCprofile profile;} {public
} 

decl {/* */ int level_PROG = -1;} {} 

declblock {\#ifdef FLU_EXPORT} {open after {\#endif}
} {
  decl {Flu_File_Chooser *dateiwahl;} {}
  Function {dateiwahl_cb(const char *dateiname, int typ, void *arg)} {open private
  } {
    code {DBG_PROG_START

    if (dateiname && dateiwahl->preview()) {
      filename_alt = dateiname;

      DBG_NUM_V( filename_alt )
      open(false);
    }

  DBG_PROG_ENDE} {selected
    }
  }
  decl {\#else} {}
  decl {Fl_File_Chooser *dateiwahl;} {}
  Function {dateiwahl_cb(Fl_File_Chooser *f,void *data)} {open private
  } {
    code {DBG_PROG_START

  const char *filename;

    Fl_File_Chooser* fl = (Fl_File_Chooser*)f;

    DBG_NUM_V( data )
    filename = fl->value();
  

    if (fl->count() && fl->value(0) && dateiwahl->preview()) {
      filename_alt = fl->value(0);

      DBG_NUM_V( filename )
      open(false);
    }

  DBG_PROG_ENDE} {}
  }
} 

Function {} {open C return_type int
} {
  code DBG_PROG_START {}
  code {statlabel = (char*)calloc (sizeof (char), 1024);
  fullscreen = false;
  inspekt_topline = 0;} {}
  Fl_Window ueber {
    label {Über ICC examin} open
    xywh {590 223 366 241} type Double resizable
    code0 {o->hide();} non_modal visible
  } {
    Fl_Group {} {open
      xywh {0 0 365 240}
    } {
      Fl_Help_View ueber_html {
        xywh {0 0 365 205} resizable
      }
      Fl_Button ja {
        label Gut
        callback {ueber->hide();}
        xywh {130 210 110 25}
      }
    }
  }
  Fl_Window details {
    label {ICC Details} open
    xywh {633 222 385 520} type Double box NO_BOX color 53
    code0 {filename_alt = ".";}
    code1 {DBG_PROG

    if (argc>1) {

      if (argc>1) {

        sprintf (statlabel, "%s geladen", argv[1]);
        stat->label(statlabel);
        filename_alt = argv[1];
      } else {
        status(_("Konnte Datei nicht laden!"));
      }
    }} xclass Fl_Window visible
  } {
    Fl_Group {} {open
      xywh {0 0 385 520}
    } {
      Fl_Menu_Bar {} {open
        xywh {0 0 385 25} color 53 align 20 when 3
      } {
        submenu {} {
          label Daten open
          xywh {15 15 100 20}
        } {
          menuitem {} {
            label {Öffnen}
            callback {open(true)}
            xywh {15 15 100 20} shortcut 0x4006f
          }
          menuitem menueintrag_html_speichern {
            label {Bericht Speichern}
            callback {std::string bericht = profile.report();
  std::string filename = filename_alt;
  filename=fl_file_chooser("Bericht Speichern", "HTML Dokumente (*.[H,h][T,t][M,m,]*)", filename_alt.c_str());
  DBG_PROG

  if (filename == "" || filename == filename_alt) {
    load_progress->hide ();
    return;
  }

  std::ofstream f ( filename.c_str(),  std::ios::out );
  f.write ( bericht.c_str(), bericht.size() );
  f.close();}
            xywh {0 0 100 20} deactivate divider
          }
          menuitem {} {
            label Beenden
            callback {quit()}
            xywh {15 15 100 20} shortcut 0x40071
          }
        }
        submenu {} {
          label Ansicht open
          xywh {15 15 100 20} divider
        } {
          menuitem menueintrag_Voll {
            label {Ganzer Bildschirm an/aus}
            callback {Fl_Window *w = (Fl_Window *)details;

  if (!fullscreen) {
    px = w->x();
    py = w->y();
    pw = w->w();
    ph = w->h();

    w->fullscreen();
    fullscreen = true;
  } else {
    w->fullscreen_off(px,py,pw,ph);
    fullscreen = false;
  }}
            xywh {15 15 100 20} shortcut 0x40076
          }
          menuitem {} {
            label {MatrixTestprofil schreiben}
            callback {Profilierer pr;
//profile.removeTag(0); //Test
pr.load (profile);
ICCprofile matrix (pr.matrix());
matrix.saveProfileToFile("/tmp/icc_examin_test.icc");}
            tooltip {zu finden in "/tmp/icc_examin_test.icc"} xywh {0 0 100 20}
          }
        }
        menuitem menueintrag_inspekt {
          label {Prüfansicht}
          callback {Fl_Menu_* mw = (Fl_Menu_*)o;
  const Fl_Menu_Item* m = mw->mvalue();

  DBG_PROG_S (m->value())
  if (m->value()) {
    mft_gl->stop();
    inspekt->show();
    examin->hide();
    inspekt_html->value(profile.report().c_str());
    inspekt_html->topline(inspekt_topline);
  } else {
    inspekt->hide();
    examin->show();
    inspekt_topline = inspekt_html->topline();
  }}
          tooltip {Mess- und Profilwerte bildlich und in Zahlen dargestellt; Ctrl+b} xywh {30 30 100 20} type Toggle shortcut 0x40062 deactivate
        }
        submenu menu_hilfe {
          label Hilfe open
          xywh {0 0 100 20}
        } {
          menuitem {} {
            label {Über}
            callback {ueber->show();
ueber_html->value(getUeberHtml().c_str());}
            xywh {5 5 100 20}
          }
        }
      }
      Fl_Group inspekt {open
        xywh {0 25 385 470}
        code0 {o->hide();}
      } {
        Fl_Help_View inspekt_html {
          label Inspect
          xywh {0 25 385 470} align 16
        }
      }
      Fl_Tile examin {open
        xywh {0 25 385 470} resizable
      } {
        Fl_Browser tag_browser {
          label {Bitte wählen Sie ein Profilmerkmal aus}
          callback {o->select_item( o->value() );}
          xywh {0 25 385 135} color 53 align 17
          code0 {int lines = tag_browser->size();}
          code1 {cout << lines << endl; DBG_PROG}
          class TagBrowser
        }
        Fl_Group ansichtsgruppe {open
          xywh {0 160 385 335}
        } {
          Fl_Group tabellengruppe {open
            xywh {0 160 385 335}
            code0 {o->show();}
          } {
            Fl_Choice mft_choice {
              label {Wählen Sie ein Kettenmerkmal}
              callback {o->auswahl_cb();} open
              xywh {0 160 385 25} box NO_BOX down_box BORDER_BOX
              code0 {o->show();}
              class MftChoice
            } {}
            Fl_Box mft_viewer {
              xywh {0 185 385 310}
              code0 {o->show();}
              class TagDrawings
            }
            Fl_Browser mft_text {
              label {Der Text}
              xywh {0 185 385 310} color 53 align 18
              code0 {o->show();}
              class TagTexts
            }
            Fl_Box mft_gl {
              xywh {0 185 385 310} align 18
              code0 {o->first = true;}
              code1 {o->hide();}
              class GL_Ansicht
            }
          }
          Fl_Group tag_3D {
            xywh {0 160 385 335}
            code0 {o->hide();}
          } {}
          Fl_Box tag_viewer {
            xywh {0 160 385 335}
            code0 {o->hide();}
            class TagDrawings
          }
          Fl_Browser tag_text {
            label {Der Text}
            xywh {0 160 385 335} color 53 align 18
            code0 {o->show();}
            class TagTexts
          }
        }
      }
      Fl_Group {} {open
        xywh {0 495 385 25}
      } {
        Fl_Box stat {
          label {No wrl file loaded.}
          xywh {0 495 385 25} box THIN_DOWN_BOX color 53 align 20
        }
        Fl_Progress load_progress {
          label {Laden ..}
          xywh {0 495 385 25} color 53
          code0 {o->hide();}
          code1 {o->maximum(1.0);}
          code2 {o->minimum(0.0);}
        }
      }
    }
  }
  code {w->resizable(tag_text);
  w->show();
  Fl::scheme(NULL);
  Fl_File_Icon::load_system_icons();

  \#ifdef FLU_EXPORT
    dateiwahl = new Flu_File_Chooser(filename_alt.c_str(), _("ICC Farbprofile (*.[I,i][C,c][M,m,C,c])"), Flu_File_Chooser::SINGLE, _("Welches ICC Profil?"));
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "ic*", "Profile Behandler", dateiwahl_cb, NULL);
  \#else
    dateiwahl = new Fl_File_Chooser(filename_alt.c_str(), _("ICC Farbprofile (*.[I,i][C,c][M,m,C,c])"), Fl_File_Chooser::SINGLE, _("Welches ICC Profil?"));
    dateiwahl->callback(dateiwahl_cb);
    dateiwahl->preview_label = _("Vorschau");
  \#endif

  if (argc > 1)
    open (false);} {}
  code DBG_PROG_ENDE {}
} 

Function {open(int interaktiv)} {open return_type {std::string}
} {
  code DBG_PROG_START {}
  code {\#include "icc_vrml.h"

  std::string filename = filename_alt;
  //Fl_File_Icon	*icon;	// New file icon
  DBG_PROG
  load_progress->show ();    load_progress->value (0.0);

  if (interaktiv) {
    dateiwahl->show(); //filename=fl_file_chooser("Wähle ICC Profil?", "ICC Farbprofile (*.[I,i][C,c][M,m,C,c])", filename_alt.c_str());
    DBG_PROG_S( filename_alt << "|" << filename)

    //while (dateiwahl->visible())
      //Fl::wait();

    DBG_NUM_V( dateiwahl->count() )
    if (dateiwahl->count() && dateiwahl->value(0)) {
      DBG_NUM_V( dateiwahl->value(0) )
      filename = dateiwahl->value(0);
    }
  }

  if (filename == "") {
    load_progress->hide ();
    return "";
  }

  // Laden
  profile.load (filename);
  // Register the ICC type ...
  //Fl_Shared_Image::add_handler(icc_check);
  //Fl_Shared_Image::add_handler(ps_check);

  std::vector<std::string> url;
  std::vector<std::string> param;

  if (/*browser && */(filename != "")) { DBG_PROG

    //create_vrml ( filename.c_str(), "/usr/share/color/icc/sRGB.icm", &vrmlDatei[0]);

    load_progress->value (0.8);
    filename_alt = filename;
    //url.push_back (&vrmlDatei[0]);
    //browser->load_url(url, param);
    sprintf (statlabel, "%s geladen", filename.c_str());
    cout << statlabel << endl; DBG_PROG
    stat->label(statlabel);
  } else {
    status(_("Datei nicht geladen!"));
  } DBG_PROG

  stat->hide();
  stat->show();
  load_progress->value (1.0);
  load_progress->value (0.0);
  load_progress->hide();
  DBG_PROG

  tag_browser->reopen ();

  if (profile.hasMeasurement()) {
    inspekt_topline = inspekt_html->topline();
    DBG_PROG_S(menueintrag_inspekt->value())
    if (menueintrag_inspekt->value()) {
      inspekt_html->value(profile.report().c_str());
      cout << inspekt_html->size() << " " << inspekt_topline; DBG_PROG
      if (inspekt_html->size() -75 < inspekt_topline)
        inspekt_html->topline (inspekt_html->size() - 75);
      else
        inspekt_html->topline (inspekt_topline);
      inspekt->show();
      examin->hide();
    }
    menueintrag_inspekt->activate();
    menueintrag_html_speichern->activate();
  } else {
    menueintrag_inspekt->deactivate();
    menueintrag_html_speichern->deactivate();
    inspekt->hide();
    examin->show();
    //menueintrag_inspekt->value( false );
  }

  return filename;} {}
  code DBG_PROG_ENDE {}
} 

Function {quit(void)} {} {
  code DBG_PROG_START {}
  code {/*Fl::remove_timeout((void (*)(void *))timeIT, (void *)viewer);
  delete viewer;
  delete browser;
  delete canvas;*/
  details->hide();
  exit(0);} {}
  code DBG_PROG_ENDE {}
} 

Function {icc_read_info(char* filename)} {return_type {char*}
} {
  code DBG_PROG_START {}
  code {char systemBefehl[1024];
  char *textfile = "/tmp/icc_temp.txt";


  sprintf (systemBefehl, "iccdump \\"%s\\" > %s",
                                    filename, textfile);
  system (systemBefehl);

  return textfile;} {}
  code DBG_PROG_ENDE {}
} 

class TagBrowser {: {public Fl_Hold_Browser}
} {
  decl {int X; int Y; int W; int H; char* start_info; std::string selectedTagName;} {}
  Function {TagBrowser(int X,int Y,int W,int H,char* start_info) : Fl_Hold_Browser(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {} {}
  Function {reopen()} {open
  } {
    code DBG_PROG_START {}
    code {//open and preparing the first selected item
  std::stringstream s;
  std::string text;
  std::vector<std::string> tag_list = profile.printTags();

  \#define add_s(stream) s << stream; add (s.str().c_str()); s.str("");
  \#define add_          s << " ";

  clear();
  add_s ("@fDateiname:")
  add_s ("@b    " << profile.filename() )
  add_s ("")
  if (tag_list.size() == 0) {
    add_s ("keine Inhalte gefunden fr \\"" << profile.filename() << "\\"")
    return;
  }
  add_s ("@B26@tNr. Bezeichner  Typ         Größe Beschreibung")
  add_s ("@t" << profile.printHeader() )
  DBG_PROG
  std::vector<std::string>::iterator it;
  for (it = tag_list.begin() ; it != tag_list.end(); ++it) {
    s << "@t";
    // Nummer
    int Nr = atoi((*it).c_str()) + 1;
    std::stringstream t; t << Nr;
    for (int i = t.str().size(); i < 3; i++) {s << " ";} s << Nr; *it++; s << " "; 
    // Name/Bezeichnung
    s << *it; for (int i = (*it++).size(); i < 12; i++) {s << " ";}
    // Typ
    s << *it; for (int i = (*it++).size(); i < 12; i++) {s << " ";}
    // Grße
    for (int i = (*it).size(); i < 5; i++) {s << " ";} s << *it++; s << " ";
    // Beschreibung
    add_s (*it)
  }
  DBG_PROG
  if (value())
    select_item (value()); // Anzeigen
  else
    select_item (1);

  if (profile.hasTagName (selectedTagName)) {
    int item = profile.getTagByName (selectedTagName) + 6;
    select_item (item);
    value(item);
  }

  std::string::size_type pos=0 , max = 0;
  std::string data = profile.filename(); DBG_NUM_S( data )
  while ((pos = data.find ("/", pos)) != std::string::npos) {
    if (pos > max) max = pos; pos++; max++;
  }
  data.erase (0, max); DBG_NUM_S( max << data )

  s.clear(); s << "ICC Details: " << data;
  details->label( (const char*) s.str().c_str() );} {}
    code DBG_PROG_ENDE {}
  }
  Function {select_item(int item)} {open
  } {
    code DBG_PROG_START {}
    code {//Auswahl aus tag_browser

  status("")

  std::string text = _("Leer");
  tag_text->hinein(text);
  item -= 6;
  cout << item << ". Tag "; DBG_PROG
  std::vector<std::string> rgb_tags;
  rgb_tags.push_back("rXYZ");
  rgb_tags.push_back("gXYZ");
  rgb_tags.push_back("bXYZ");

  if (item < 0) {
    select(5);
    text = profile.printLongHeader(); DBG_PROG
    tag_text->hinein(text);    
  } else if (item >= 0) {
    std::vector<std::string> TagInfo = profile.printTagInfo(item);
    DBG_PROG_S( TagInfo.size() << " " << TagInfo[0] << " " << TagInfo[1] )

    if        ( TagInfo[1] == "text"
             || TagInfo[1] == "cprt?"
             || TagInfo[1] == "meas"
             || TagInfo[1] == "sig"
             || TagInfo[1] == "dtim") {
      tag_text->hinein ( (profile.getTagText (item))[0] ); DBG_PROG
    } else if ( TagInfo[1] == "desc" ) {
      tag_text->hinein( (profile.getTagDescription (item))[0] ); DBG_PROG
    } else if ( TagInfo[0] == "rXYZ" || TagInfo[0] == "gXYZ" || TagInfo[0] == "bXYZ" ) {
      std::vector<double> alle_punkte, punkte;
      std::vector<std::string> alle_texte;
      std::string TagName;
      for (unsigned int i_name = 0; i_name < rgb_tags.size(); i_name++) {
        if (profile.hasTagName (rgb_tags[i_name])) {
          punkte = profile.getTagCIEXYZ (profile.getTagByName(rgb_tags[i_name]));
          for (unsigned int i = 0; i < 3; i++)
            alle_punkte.push_back (punkte[i]);
          TagInfo = profile.printTagInfo (profile.getTagByName(rgb_tags[i_name]));
          for (unsigned int i = 0; i < 2; i++)
            alle_texte.push_back (TagInfo[i]);
        }
      }
      tag_viewer->hinein_punkt( alle_punkte, alle_texte );
    } else if ( TagInfo[1] == "curv"
             || TagInfo[1] == "bfd" ) {
      std::vector<std::vector<double> > kurven;
      std::vector<double> kurve;
      std::vector<std::string> texte;
      std::string TagName;
      for (int i_name = 0; i_name < profile.tagCount(); i_name++) {
        if ( (profile.printTagInfo(i_name))[1] == "curv"
          || (profile.printTagInfo(i_name))[1] == "bfd" ) {
          kurve = profile.getTagCurve (i_name);
          kurven.push_back (kurve);
          TagInfo = profile.printTagInfo (i_name);
          //for (unsigned int i = 0; i < 2; i++)
          texte.push_back (TagInfo[0]);
        }
      }
      texte.push_back ("curv");
      tag_viewer->hinein_kurven( kurven, texte );
    } else if ( TagInfo[1] == "chrm") {
      tag_viewer->hinein_punkt( profile.getTagCIEXYZ(item), profile.getTagText(item) );
    } else if ( TagInfo[1] == "XYZ" ) {
      tag_viewer->hinein_punkt( profile.getTagCIEXYZ(item), TagInfo );
    } else if ( TagInfo[1] == "mft2"
             || TagInfo[1] == "mft1" ) {
      mft_choice->profil_tag (item);
      //mft_text->hinein ( (profile.getTagText (item))[0] ); DBG_PROG
    } else if ( TagInfo[1] == "vcgt" ) { DBG_PROG
      tag_viewer->hinein_kurven ( profile.getTagCurves (item, ICCtag::CURVE_IN),
                                  profile.getTagText (item) ); cout << "vcgt "; DBG_PROG
    }
    selectedTagName = TagInfo[0];
  }DBG_PROG} {}
    code DBG_PROG_ENDE {}
  }
} 

class TagTexts {: {public Fl_Hold_Browser}
} {
  decl {int X; int Y; int W; int H; char* start_info;} {}
  Function {TagTexts(int X,int Y,int W,int H,char* start_info) : Fl_Hold_Browser(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {open
  } {}
  Function {hinein(std::string text)} {open
  } {
    code DBG_PROG_START {}
    code {//Text aus tag_browser anzeigen

  zeig_mich(this); DBG_PROG

      this->clear();

      std::vector <std::string> texte = zeilenNachVector( text );
      for (unsigned int i = 0; i < texte.size(); i++)
        this->add( texte[i].c_str(), 0);


      this->topline(0);
      this->textfont(FL_COURIER);
      this->textsize(14);} {}
    code DBG_PROG_ENDE {}
  }
} 

class TagDrawings {open : {public Fl_Widget}
} {
  decl {int X; int Y; int W; int H; std::vector<std::string>texte; std::vector<double>punkte; std::vector<std::vector<double> >kurven;} {}
  decl {int wiederholen;} {public
  }
  Function {TagDrawings(int X,int Y,int W,int H) : Fl_Widget(X,Y,W,H), X(X), Y(Y), W(W), H(H)} {} {}
  Function {draw()} {open
  } {
    code DBG_PROG_START {}
    code {// Kurven oder Punkte malen
  DBG_PROG_S( punkte.size() << "/" << kurven.size() <<" "<< texte.size() )

  //DBG_PROG_V( wiederholen )

  if (punkte.size() >= 3) {
    if (wiederholen) {
      draw_cie_shoe(x(),y(),w(),h(),texte,punkte,false);
      Fl::add_timeout( 1.2, (void(*)(void*))d_haendler ,(void*)this);
    } else {
      draw_cie_shoe(x(),y(),w(),h(),texte,punkte,true);
    }
    wiederholen = true;
  } else {
    wiederholen = false;
    draw_kurve   (x(),y(),w(),h(),texte,kurven);
  }
  DBG_PROG} {}
    code DBG_PROG_ENDE {}
  }
  Function {hinein_punkt(std::vector<double> vect, std::vector<std::string> txt)} {open
  } {
    code DBG_PROG_START {}
    code {//CIExyY aus tag_browser anzeigen
  punkte.clear();
  for (unsigned int i = 0; i < vect.size(); i++)
    punkte.push_back (vect[i]);
  texte.clear();
  for (unsigned int i = 0; i < txt.size(); i++)
    texte.push_back (txt[i]);
  kurven.clear();
  wiederholen = false;

  zeig_mich(this);} {}
    code DBG_PROG_ENDE {}
  }
  Function {hinein_kurven(std::vector<std::vector<double> >vect, std::vector<std::string> txt)} {open
  } {
    code DBG_PROG_START {}
    code {//Kurve aus tag_browser anzeigen
  kurven = vect;
  texte = txt;
  punkte.clear();
  wiederholen = false;

  zeig_mich(this);
  DBG_PROG} {}
    code DBG_PROG_ENDE {}
  }
  Function {ruhig_neuzeichnen(void)} {open return_type void
  } {
    code DBG_PROG_START {}
    code {draw_cie_shoe(x(),y(),w(),h(),texte,punkte,true);} {}
    code DBG_PROG_ENDE {}
  }
} 

decl {\#include <FL/fl_draw.H>} {} 

class MftChoice {: {public Fl_Choice}
} {
  decl {int X; int Y; int W; int H; char* start_info; char typ[5]; std::vector<std::string> Info; int gewaehlter_eintrag;} {}
  Function {MftChoice(int X,int Y,int W,int H,char* start_info) : Fl_Choice(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {open
  } {
    code {gewaehlter_eintrag = 0;} {}
  }
  Function {profil_tag(int _tag)} {open
  } {
    code DBG_PROG_START {}
    code {tag_nummer = _tag;

// = profile.printTagInfo(tag_nummer);
    sprintf (&typ[0], profile.printTagInfo(tag_nummer)[1].c_str());

    Info = zeilenNachVector (profile.getTagText (tag_nummer)[0]);

    if ( strstr (typ,"mft2") != 0 )
    {
      Fl_Menu_Item *mft_menue = (Fl_Menu_Item *)calloc (sizeof (Fl_Menu_Item), 6);

      mft_menue[0].text = Info[0].c_str();
      mft_menue[1].text = Info[4].c_str();
      mft_menue[2].text = Info[5].c_str();
      mft_menue[3].text = Info[6].c_str();
      mft_menue[4].text = Info[7].c_str();
      mft_menue[5].text = 0;
      mft_choice->menu(mft_menue);
    } else {
      Fl_Menu_Item *mft_menue = (Fl_Menu_Item *)calloc (sizeof (Fl_Menu_Item), 6);

      mft_menue[0].text = Info[0].c_str();
      mft_menue[1].text = Info[4].c_str();
      mft_menue[2].text = "lineare Eingangskurve mit 256 Stufungen";
      mft_menue[3].text = Info[5].c_str();
      mft_menue[4].text = "lineare Ausgangskurve mit 256 Stufungen";
      mft_menue[5].text = 0;
      mft_choice->menu(mft_menue);
    }

    mft_choice->value( gewaehlter_eintrag );

  zeig_mich (this);
  auswahl_cb();} {}
    code DBG_PROG_ENDE {}
  }
  Function {auswahl_cb(void)} {open
  } {
    code DBG_PROG_START {}
    code {//Auswahl aus mft_choice

  status("")

  Fl_Menu_* mw = (Fl_Menu_*)this;
  const Fl_Menu_Item* m = mw->mvalue();
  if (!m) {
    DBG_PROG_S("NULL \\n")
  } else if (m->shortcut()) {
    DBG_PROG_S("%s - %s \\n" << m->label() << fl_shortcut_label(m->shortcut()))
  } else {
    DBG_PROG_S("%s \\n" << m->label())
  }

  std::stringstream s;
  std::vector<double> zahlen;

  switch (mw->value()) {
  case 0: // Überblick
    { for (unsigned int i = 1; i < Info.size(); i++) // erste Zeile weglassen
        s << Info [i] << endl;
      mft_text->hinein ( s.str() ); DBG_PROG // anzeigen
    } break;
  case 1: // Matriz
    zahlen = profile.getTagNumbers (tag_nummer, ICCtag::MATRIX);
    cout << zahlen.size() << endl; DBG_PROG
    assert (9 == zahlen.size());
    s << endl <<
    "  " << zahlen[0] << ", " << zahlen[1] << ", " << zahlen[2] << ", " << endl <<
    "  " << zahlen[3] << ", " << zahlen[4] << ", " << zahlen[5] << ", " << endl <<
    "  " << zahlen[6] << ", " << zahlen[7] << ", " << zahlen[8] << ", " << endl;
    mft_text->hinein ( s.str() ); DBG_PROG
    break;
  case 2: // Eingangskurven
    DBG_PROG
    mft_viewer->hinein_kurven (
                     profile.getTagCurves (tag_nummer, ICCtag::CURVE_IN),
                     profile.getTagChannelNames (tag_nummer, ICCtag::CURVE_IN) ); DBG_PROG
    break;
  case 3: // 3D Tabelle
    DBG_PROG
    mft_gl->hinein_tabelle (
                     profile.getTagTable (tag_nummer, ICCtag::TABLE),
                     profile.getTagChannelNames (tag_nummer, ICCtag::TABLE),
                     profile.getPCSNames () ); DBG_PROG
    break;
  case 4: // Ausgangskurven
    mft_viewer->hinein_kurven (
                     profile.getTagCurves (tag_nummer, ICCtag::CURVE_OUT),
                     profile.getTagChannelNames (tag_nummer, ICCtag::CURVE_OUT) ); DBG_PROG
    break;
  }

  gewaehlter_eintrag = mw->value();} {}
    code DBG_PROG_ENDE {}
  }
} 

Function {d_haendler(void* o)} {return_type {static void}
} {
  code DBG_PROG_START {}
  code {Fl::remove_timeout( (void(*)(void*))d_haendler, 0 );
  if (!Fl::has_timeout( (void(*)(void*))d_haendler, 0 )
   && ((TagDrawings*)o)->active()
   && ((TagDrawings*)o)->visible_r()
   && ((TagDrawings*)o)->wiederholen) {
    ((TagDrawings*)o)->ruhig_neuzeichnen();
    \#ifdef DEBUG
    DBG_PROG_V( ((TagDrawings*)o)->wiederholen )
    \#endif
  }} {}
  code DBG_PROG_ENDE {}
} 

Function {zeig_mich(void* widget)} {open
} {
  code DBG_PROG_START {}
  code {// zeigt das ausgewählte Fenster (widget)

  //tabellengruppe->hide();
  mft_viewer->hide();
  mft_text->hide();
  //mft_gl->hide();
  
  tag_viewer->hide(); DBG_PROG
  tag_viewer->clear_visible(); DBG_PROG
  tag_text->hide();
  if (widget != mft_gl) {
    mft_gl->verstecken();
    //((Fl_Widget*)widget)->parent()->show(); DBG_PROG
    ((Fl_Widget*)widget)->show(); DBG_PROG
  } else {
    DBG_PROG_S( "GL Fenster belassen." )
    mft_gl->zeigen();
  }} {}
  code DBG_PROG_ENDE {}
} 

Function {zeilenNachVector(std::string text)} {return_type {std::vector<std::string>}
} {
  code DBG_PROG_START {}
  code {// fügt Zeilen aus einen Text in einen Vector
  std::vector <std::string> texte;

      int len = strlen(text.c_str());
      std::string text_line;
      char c;
      const char *chars = text.c_str();
      for (int zeichen = 0; zeichen < len; zeichen++) {
        c = chars[zeichen];
        if (c == '\\n' || (int)c == 0) { // LF oder 0
          text_line += '\\0';
          texte.push_back(text_line.c_str());
          text_line.clear();
        } else
          text_line += c;
      }
      if (text_line.size() > 0) // falls was übrig bleibt
        texte.push_back(text_line.c_str());

  DBG_PROG_ENDE
  return texte;} {}
} 
