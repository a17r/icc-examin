# data file for the Fltk User Interface Designer (fluid)
version 1.0104 
header_name {.h} 
code_name {.cxx}
decl {\#define DEBUG} {public
} 

decl {\#include <cassert>} {public
} 

decl {\#include <iostream>} {public
} 

decl {//\#include <sstream>} {public
} 

decl {\#include <stdio.h>} {public
} 

decl {\#include <string>} {public
} 

decl {\#include <vector>} {public
} 

decl {\#include <FL/Fl.H>} {public
} 

decl {\#include <FL/Fl_Window.H>} {public
} 

decl {\#include <FL/Fl_Menu_Bar.H>} {public
} 

decl {\#include <FL/Fl_Box.H>} {public
} 

decl {\#include "icc_fenster.h" 
\#include <FL/Fl_Hold_Browser.H>} {public
} 

decl {class TagDrawings;
class TagBrowser;
class TagTexts;
class MftChoice;
class GL_Ansicht;} {public
} 

decl {\#include "icc_examin.h"} {public
} 

decl {\#include "icc_draw.h"
\#include "icc_kette.h"
\#include "icc_oyranos.h"
\#include "fl_oyranos.h"} {} 

decl {\#include "icc_profile.h"
\#include "icc_utils.h"
\#include "icc_ueber.h"} {public
} 

decl {\#include "agviewer.h"
\#include "icc_gl.h"} {} 

Function {icc_read_info(char* filename)} {return_type {char*}
} {
  code DBG_PROG_START {}
  code {char systemBefehl[1024];
  char *textfile = "/tmp/icc_temp.txt";


  sprintf (systemBefehl, "iccdump \\"%s\\" > %s",
                                    filename, textfile);
  system (systemBefehl);

  return textfile;} {}
  code DBG_PROG_ENDE {}
} 

class TagBrowser {: {public Fl_Hold_Browser}
} {
  decl {int X; int Y; int W; int H; char* start_info; std::string selectedTagName;} {}
  Function {TagBrowser(int X,int Y,int W,int H,char* start_info) : Fl_Hold_Browser(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {} {}
  Function {reopen()} {open
  } {
    code DBG_PROG_START {}
    code {//open and preparing the first selected item

  std::stringstream s;
  std::string text;
  std::vector<std::string> tag_list = profile.profil()->printTags();

  \#define add_s(stream) s << stream; add (s.str().c_str()); s.str("");
  \#define add_          s << " ";

  clear();
  add_s ("@fDateiname:")
  add_s ("@b    " << profile.profil()->filename() )
  add_s ("")
  if (tag_list.size() == 0) {
    add_s ("keine Inhalte gefunden für \\"" << profile.profil()->filename() << "\\"")
    return;
  }
  add_s ("@B26@tNr. Bezeichner  Typ         Größe Beschreibung")
  add_s ("@t" << profile.profil()->printHeader() )
  DBG_PROG
  std::vector<std::string>::iterator it;
  for (it = tag_list.begin() ; it != tag_list.end(); ++it) {
    s << "@t";
    // Nummer
    int Nr = atoi((*it).c_str()) + 1;
    std::stringstream t; t << Nr;
    for (int i = t.str().size(); i < 3; i++) {s << " ";} s << Nr; *it++; s << " "; 
    // Name/Bezeichnung
    s << *it; for (int i = (*it++).size(); i < 12; i++) {s << " ";}
    // Typ
    s << *it; for (int i = (*it++).size(); i < 12; i++) {s << " ";}
    // Größe
    for (int i = (*it).size(); i < 5; i++) {s << " ";} s << *it++; s << " ";
    // Beschreibung
    add_s (*it)
  }
  DBG_PROG
  if (value())
    selectItem (value()); // Anzeigen
  else
    selectItem (1);

  if (profile.profil()->hasTagName (selectedTagName)) {
    int item = profile.profil()->getTagByName (selectedTagName) + 6;
    selectItem (item);
    value(item);
  }

  std::string::size_type pos=0 , max = 0;
  std::string data = profile.profil()->filename(); DBG_NUM_S( data )
  while ((pos = data.find ("/", pos)) != std::string::npos) {
    if (pos > max) max = pos; pos++; max++;
  }
  data.erase (0, max); DBG_NUM_S( max << data )

  s.clear(); s << "ICC Details: " << data;
  status ((const char*) s.str().c_str() );} {}
    code DBG_PROG_ENDE {}
  }
  Function {selectItem(int item)} {open
  } {
    code DBG_PROG_START {}
    code {//Auswahl aus tag_browser

  status("")

  item -= 6;
  DBG_PROG_S( item << ". Tag " )
  
  std::string text = icc_examin->waehleTag(item);
  if (text != "")
    selectedTagName = text;
  DBG_PROG_V( text );} {}
    code DBG_PROG_ENDE {}
  }
} 

class TagTexts {: {public Fl_Hold_Browser}
} {
  decl {int X; int Y; int W; int H; char* start_info;} {}
  decl {int inspekt_topline;} {public
  }
  Function {TagTexts(int X,int Y,int W,int H,char* start_info) : Fl_Hold_Browser(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {open
  } {}
  Function {hinein(std::string text)} {open
  } {
    code DBG_PROG_START {}
    code {//Text aus tag_browser anzeigen

      this->clear();

      std::vector <std::string> texte = zeilenNachVector( text );
      for (unsigned int i = 0; i < texte.size(); i++)
        this->add( texte[i].c_str(), 0);


      this->topline(0);
      this->textfont(FL_COURIER);
      this->textsize(14);} {}
    code DBG_PROG_ENDE {}
  }
} 

class TagDrawings {: {public Fl_Widget}
} {
  decl {int X, Y, W, H;} {}
  decl {int wiederholen, id;} {public
  }
  Function {TagDrawings(int X,int Y,int W,int H) : Fl_Widget(X,Y,W,H), X(X), Y(Y), W(W), H(H)} {open
  } {}
  Function {draw()} {open
  } {
    code DBG_PROG_START {}
    code {// Kurven oder Punkte malen
  DBG_PROG_S( icc_examin->kurven[id].size() <<" "<< icc_examin->punkte[id].size() )

  //DBG_PROG_V( wiederholen )

  if (icc_examin->kurven[id].size())
  { DBG_PROG
    wiederholen = false;
    drawKurve (id, x(),y(),w(),h());
  } else if (icc_examin->punkte[id].size()) {
    if (wiederholen)
    { drawCieShoe(id, x(),y(),w(),h(),false);
      Fl::add_timeout( 1.2, (void(*)(void*))dHaendler ,(void*)this);
    } else {
      drawCieShoe(id, x(),y(),w(),h(),true);
    }
    wiederholen = true;
  }
  DBG_PROG} {}
    code DBG_PROG_ENDE {}
  }
  Function {hineinPunkt(std::vector<double> &vect, std::vector<std::string> &txt)} {} {
    code DBG_PROG_START {}
    code {//CIExyY aus tag_browser anzeigen

  wiederholen = false;} {}
    code DBG_PROG_ENDE {}
  }
  Function {hineinKurven(std::vector<std::vector<double> > &vect, std::vector<std::string> &txt)} {} {
    code DBG_PROG_START {}
    code {//Kurve aus tag_browser anzeigen

  wiederholen = false;

  DBG_PROG} {}
    code DBG_PROG_ENDE {}
  }
  Function {ruhigNeuzeichnen(void)} {open return_type void
  } {
    code DBG_PROG_START {}
    code {drawCieShoe(id, x(),y(),w(),h(),true);} {}
    code DBG_PROG_ENDE {}
  }
} 

decl {\#include <FL/fl_draw.H>} {} 

class MftChoice {: {public Fl_Choice}
} {
  decl {int X; int Y; int W; int H; char* start_info; char typ[5];} {}
  decl {std::vector<std::string> Info; int gewaehlter_eintrag;} {public
  }
  Function {MftChoice(int X,int Y,int W,int H,char* start_info) : Fl_Choice(X,Y,W,H,start_info), X(X), Y(Y), W(W), H(H)} {open
  } {
    code {gewaehlter_eintrag = 0;} {}
  }
  Function {profilTag(int _tag, std::string text)} {open
  } {
    code DBG_PROG_START {}
    code {icc_examin->icc_betrachter->tag_nummer = _tag;

// = profile.profil()->printTagInfo(icc_examin->icc_betrachter->tag_nummer);
    sprintf (&typ[0], profile.profil()->printTagInfo(icc_examin->icc_betrachter->tag_nummer)[1].c_str());

    DBG_PROG_V( profile.profil()->printTagInfo(icc_examin->icc_betrachter->tag_nummer)[1].c_str() )

    Info = zeilenNachVector (text);

    if ( strstr (typ,"mft2") != 0 )
    { DBG_PROG
      Fl_Menu_Item *mft_menue = (Fl_Menu_Item *)calloc (sizeof (Fl_Menu_Item), 6);

      mft_menue[0].text = Info[0].c_str();
      mft_menue[1].text = Info[4].c_str();
      mft_menue[2].text = Info[5].c_str();
      mft_menue[3].text = Info[6].c_str();
      mft_menue[4].text = Info[7].c_str();
      mft_menue[5].text = 0;
      icc_examin->icc_betrachter->mft_choice->menu(mft_menue);
    } else { DBG_PROG
      Fl_Menu_Item *mft_menue = (Fl_Menu_Item *)calloc (sizeof (Fl_Menu_Item), 6);

      mft_menue[0].text = Info[0].c_str();
      mft_menue[1].text = Info[4].c_str();
      mft_menue[2].text = "lineare Eingangskurve mit 256 Stufungen";
      mft_menue[3].text = Info[5].c_str();
      mft_menue[4].text = "lineare Ausgangskurve mit 256 Stufungen";
      mft_menue[5].text = 0;
      icc_examin->icc_betrachter->mft_choice->menu(mft_menue);
    }

    icc_examin->icc_betrachter->mft_choice->value( gewaehlter_eintrag );

  //auswahlCb();} {}
    code DBG_PROG_ENDE {}
  }
  Function {auswahlCb(void)} {open
  } {
    code DBG_PROG_START {}
    code {//Auswahl aus mft_choice

  status("")

  Fl_Menu_* mw = (Fl_Menu_*)this;
  const Fl_Menu_Item* m = mw->mvalue();
  if (!m) {
    DBG_PROG_S("NULL \\n")
  } else if (m->shortcut()) {
    DBG_PROG_S("%s - %s \\n" << m->label() << fl_shortcut_label(m->shortcut()))
  } else {
    DBG_PROG_S("%s \\n" << m->label())
  }

  icc_examin->waehleMft( mw->value() );

  DBG_PROG} {}
    code DBG_PROG_ENDE {}
  }
} 

class ICCfltkBetrachter {open
} {
  decl {bool setTitleUrl;

 int px,py,pw,ph;
 int fullscreen;
  
 int tag_nummer;} {public
  }
  Function {init()} {open
  } {
    code DBG_PROG_START {}
    code {fullscreen = false;
  setTitleUrl = true;

  \#ifdef HAVE_FLU
    Flu_File_Chooser::favoritesTxt = _("Lesezeichen");
    Flu_File_Chooser::myComputerTxt = _("Heimverzeichnis");
    Flu_File_Chooser::myDocumentsTxt = _("Dokumente");
    Flu_File_Chooser::desktopTxt = _("Desktop");

    Flu_File_Chooser::filenameTxt = _("Dateiname");
    Flu_File_Chooser::okTxt = _("Ja");
    Flu_File_Chooser::cancelTxt = _("Abbrechen");
    Flu_File_Chooser::locationTxt = _("Ordner");
    Flu_File_Chooser::showHiddenTxt = _("zeige versteckte Dateien");
    Flu_File_Chooser::fileTypesTxt = _("Datei Typen");
    Flu_File_Chooser::directoryTxt = _("Verzeichnis");
    Flu_File_Chooser::allFilesTxt = _("Alle Dateien (*)");
    Flu_File_Chooser::defaultFolderNameTxt = _("Neues Verzeichnis");

    Flu_File_Chooser::backTTxt = _("vorheriges Verzeichnis");
    Flu_File_Chooser::forwardTTxt = _("nächstes Verzeichnis");
    Flu_File_Chooser::upTTxt = _("nächsthöheres Verzeichnis");
    Flu_File_Chooser::reloadTTxt = _("Auffrischen");
    Flu_File_Chooser::trashTTxt = _("Löschen");
    Flu_File_Chooser::newDirTTxt = _("Verzeichnis erstellen");
    Flu_File_Chooser::addFavoriteTTxt = _("zu Lesezeichen");
    Flu_File_Chooser::previewTTxt = _("Vorschau");
    Flu_File_Chooser::listTTxt = _("Standard Anzeige");
    Flu_File_Chooser::wideListTTxt = _("weite Anzeige");
    Flu_File_Chooser::detailTTxt = _("detailierte Informationen");

    Flu_File_Chooser::detailTxt[0] = _("Name");
    Flu_File_Chooser::detailTxt[3] = _("Typ");
    Flu_File_Chooser::detailTxt[1] = _("Grösse");
    Flu_File_Chooser::detailTxt[2] = _("Datum");
    Flu_File_Chooser::contextMenuTxt[0] = _("contextMenuTxt 0");
    Flu_File_Chooser::contextMenuTxt[1] = _("Umbenennen");
    Flu_File_Chooser::contextMenuTxt[2] = _("Löschen");
    Flu_File_Chooser::diskTypesTxt[0] = _("Typ1");
    Flu_File_Chooser::diskTypesTxt[1] = _("Typ2");
    Flu_File_Chooser::diskTypesTxt[2] = _("Typ3");
    Flu_File_Chooser::diskTypesTxt[3] = _("Typ4");
    Flu_File_Chooser::diskTypesTxt[4] = _("Typ5");
    Flu_File_Chooser::diskTypesTxt[5] = _("Typ6");

    Flu_File_Chooser::createFolderErrTxt = _("Ordner konnte nicht erstellt werden");
    Flu_File_Chooser::deleteFileErrTxt = _("konnte Datei nicht löschen");
    Flu_File_Chooser::fileExistsErrTxt = _("Datei existiert");
    Flu_File_Chooser::renameErrTxt = _("kontte nicht umbenennen");

/*    Flu_File_Chooser:: = _("");
    Flu_File_Chooser:: = _("");
    Flu_File_Chooser:: = _("");
    Flu_File_Chooser:: = _("");
    Flu_File_Chooser:: = _("");*/

    const char* ptr = NULL;
    if (profile.size())
      ptr = profile.name().c_str();
    dateiwahl = new Flu_File_Chooser(ptr, _("ICC Farbprofile (*.ic*)"), Flu_File_Chooser::SINGLE, _("Welches ICC Profil?"));
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "icc", _("Profil öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "icm", _("Profil öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "it8", _("Messdatei öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "txt", _("Messdatei öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "IT8", _("Messdatei öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "Q60", _("Messdatei öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "LAB", _("Messdatei öffnen"), dateiwahl_cb, NULL);
    dateiwahl->add_context_handler(Flu_File_Chooser::ENTRY_FILE, "CMYK", _("Messdatei öffnen"), dateiwahl_cb, NULL);
  \#else
    const char* ptr = NULL;
    if (profile.size())
      ptr = profile.name().c_str();
    dateiwahl = new Fl_File_Chooser(ptr, _("ICC Farbprofile (*.{I,i}{C,c}{M,m,C,c})"), Fl_File_Chooser::SINGLE, _("Welches ICC Profil?"));
    dateiwahl->callback(dateiwahl_cb);
    dateiwahl->preview_label = _("Vorschau");
  \#endif} {}
    Fl_Window ueber {
      label {Über ICC examin} open
      xywh {567 641 366 241} type Double hide resizable
      code0 {o->hide();} non_modal
    } {
      Fl_Group {} {open
        xywh {0 0 365 240}
      } {
        Fl_Help_View ueber_html {
          xywh {0 0 365 205} resizable
        }
        Fl_Button ja {
          label Gut
          callback {ueber->hide();}
          xywh {130 210 110 25}
        }
      }
    }
    Fl_Window vcgt {
      label {Grafikkarten Gamma Tabellen} open
      xywh {721 272 370 390} type Double labeltype NORMAL_LABEL resizable
      code0 {o->hide();} non_modal visible
    } {
      Fl_Group {} {open
        xywh {0 0 370 390}
      } {
        Fl_Box vcgt_viewer {
          xywh {0 0 370 360}
          code0 {o->show();}
          class TagDrawings
        }
        Fl_Button {} {
          label Gut
          callback {vcgt->hide();}
          xywh {255 360 110 25}
        }
        Fl_Button {} {
          label Auffrischen
          callback {icc_examin->vcgtZeigen();}
          xywh {135 360 110 25} hotspot
        }
      }
    }
    Fl_Window details {
      label {ICC Details} open
      xywh {606 427 385 520} type Double box NO_BOX color 53 xclass Fl_Window visible
    } {
      Fl_Group {} {open
        xywh {0 0 385 520}
      } {
        Fl_Menu_Bar {} {open
          xywh {0 0 385 25} align 20 when 3
        } {
          submenu {} {
            label Daten open
            xywh {15 15 100 20}
          } {
            menuitem {} {
              label {Öffnen}
              callback {icc_examin->oeffnen()}
              xywh {15 15 100 20} shortcut 0x4006f
            }
            menuitem menueintrag_html_speichern {
              label {Bericht Speichern}
              callback {DBG_PROG_START

  icc_examin->berichtSpeichern ();

  DBG_PROG_ENDE}
              xywh {0 0 100 20} deactivate divider
            }
            menuitem {} {
              label Beenden
              callback {quit()}
              xywh {15 15 100 20} shortcut 0x40071
            }
          }
          submenu {} {
            label Bearbeiten open
            xywh {25 25 100 20}
          } {
            menuitem {} {
              label Voreinstellungen
              callback {voreinstellungen()}
              xywh {25 25 100 20}
            }
          }
          submenu {} {
            label Ansicht open
            xywh {15 15 100 20} divider
          } {
            menuitem menueintrag_Voll {
              label {Ganzer Bildschirm an/aus}
              callback {Fl_Window *w = (Fl_Window *)details;

  if (!fullscreen) {
    px = w->x();
    py = w->y();
    pw = w->w();
    ph = w->h();

    w->fullscreen();
    fullscreen = true;
  } else {
    w->fullscreen_off(px,py,pw,ph);
    fullscreen = false;
  }}
              xywh {15 15 100 20} shortcut 0x40076
            }
            menuitem menueintrag_inspekt {
              label {Prüfansicht}
              callback {Fl_Menu_* mw = (Fl_Menu_*)o;
  const Fl_Menu_Item* m = mw->mvalue();

  DBG_PROG_S (m->value())

  if (m->value())
  { inspekt_html->value(profile.profil()->report().c_str());
    inspekt_html->topline(tag_text->inspekt_topline);
  } else {
    tag_text->inspekt_topline = inspekt_html->topline();
  }
  icc_examin->neuzeichnen(inspekt_html);}
              tooltip {Mess- und Profilwerte bildlich und in Zahlen dargestellt; Ctrl+b} xywh {40 40 100 20} type Toggle shortcut 0x40062 deactivate
            }
            menuitem menueintrag_zeigcgats {
              label {CGATS Ansicht}
              callback {Fl_Menu_* mw = (Fl_Menu_*)o;
  const Fl_Menu_Item* m = mw->mvalue();

  DBG_PROG_S (m->value())

  icc_examin->zeigCGATS();} selected
              tooltip {Mess- und Profilwerte bildlich und in Zahlen dargestellt; Ctrl+b} xywh {50 50 100 20} shortcut 0x40067 deactivate
            }
            menuitem menueintrag_3D {
              label {3D Ansicht}
              callback {Fl_Menu_* mw = (Fl_Menu_*)o;
  const Fl_Menu_Item* m = mw->mvalue();

  DBG_PROG_S (m->value())
  if (m->value()) {
    icc_examin->histogram();
  }
  icc_examin->neuzeichnen(DD_histogram);}
              xywh {50 50 100 20} type Toggle shortcut 0x40068 divider
            }
            menuitem menueintrag_vcgt {
              label {Grafikkarten Gamma}
              callback {vcgt->show();
icc_examin->vcgtZeigen();}
              xywh {15 15 100 20} shortcut 0x40067
              code0 {o->hide();}
            }
          }
          submenu menu_hilfe {
            label Hilfe open
            xywh {0 0 100 20}
          } {
            menuitem {} {
              label {Über}
              callback {ueber->show();
ueber_html->value(getUeberHtml().c_str());}
              xywh {5 5 100 20}
            }
          }
        }
        Fl_Tile examin {open
          xywh {0 25 385 470} resizable
        } {
          Fl_Help_View inspekt_html {
            label Inspect
            xywh {0 25 385 470} align 16
            code0 {o->hide();}
          }
          Fl_Browser tag_browser {
            label {Bitte wählen Sie ein Profilmerkmal aus}
            callback {o->selectItem( o->value() );}
            xywh {0 25 385 135} color 49 align 17 textcolor 32
            code0 {int lines = tag_browser->size();}
            code1 {DBG_PROG_V( lines )}
            class TagBrowser
          }
          Fl_Group ansichtsgruppe {open
            xywh {0 160 385 335}
          } {
            Fl_Group tabellengruppe {open
              xywh {0 160 385 335}
              code0 {o->show();}
            } {
              Fl_Choice mft_choice {
                label {Wählen Sie ein Kettenmerkmal}
                callback {o->auswahlCb();} open
                xywh {0 160 385 25} box NO_BOX down_box BORDER_BOX color 49
                code0 {o->show();}
                class MftChoice
              } {}
              Fl_Box mft_viewer {
                xywh {0 185 385 310}
                code0 {o->show();}
                class TagDrawings
              }
              Fl_Browser mft_text {
                label {Der Text}
                xywh {0 185 385 310} color 48 align 18 textcolor 32
                code0 {o->show();}
                class TagTexts
              }
              Fl_Box mft_gl {
                xywh {0 185 385 310} align 18
                code0 {o->hide();}
                class GL_Ansicht
              }
            }
            Fl_Box tag_viewer {
              xywh {0 160 385 335}
              code0 {o->hide();}
              class TagDrawings
            }
            Fl_Browser tag_text {
              label {Der Text}
              xywh {0 160 385 335} color 49 align 18 textcolor 32
              code0 {o->show();}
              class TagTexts
            }
          }
          Fl_Box DD_histogram {
            xywh {0 25 385 470}
            code0 {o->hide();}
            class GL_Ansicht
          }
        }
        Fl_Group {} {open
          xywh {0 495 385 25}
        } {
          Fl_Box box_stat {
            label {No wrl file loaded.}
            xywh {0 495 385 25} box THIN_DOWN_BOX align 20
          }
          Fl_Progress load_progress {
            label {Laden ..}
            xywh {0 495 385 25}
            code0 {o->hide();}
            code1 {o->maximum(1.0);}
            code2 {o->minimum(0.0);}
          }
        }
      }
    }
    code {tag_text->inspekt_topline = 0;

  w->resizable(tag_text);
  w->show();
  Fl::scheme(NULL);
  Fl_File_Icon::load_system_icons();} {}
    code DBG_PROG_ENDE {}
  }
  Function {run()} {} {
    code DBG_PROG_START {}
    code {DBG_PROG_ENDE;  Fl::run();} {}
  }
  Function {open(std::vector<std::string> dateinamen)} {return_type {std::vector<std::string>}
  } {
    code DBG_PROG_START {}
    code {\#include "icc_vrml.h"

  //Fl_File_Icon	*icon;	// New file icon
  DBG_PROG
  load_progress->show ();    load_progress->value (0.0);

    const char* ptr = NULL;
    if (dateinamen.size()) {
      ptr = dateinamen[0].c_str();
      dateiwahl->value(ptr);
      //DBG_PROG_S( dateinamen[0])
    }
    dateiwahl->show(); //filename=fl_file_chooser("Wähle ICC Profil?", "ICC Farbprofile (*.{I,i}{C,c}{M,m,C,c})", filenamen_alt[0].c_str());

    


    while (dateiwahl->visible())
      Fl::wait();

    DBG_NUM_V( dateiwahl->count() )
    if (dateiwahl->count() && dateiwahl->value()) {
      DBG_NUM_V( dateiwahl->value() )
      dateinamen.resize(dateiwahl->count());
      for (int i = 1; i <= dateiwahl->count(); i++)
        dateinamen[i-1] = dateiwahl->value(i);
    }
  DBG_PROG

  if (dateinamen.size() == 0) {
    load_progress->hide ();

    DBG_PROG_ENDE
    return dateinamen;
  }

  DBG_PROG_ENDE
  return dateinamen;} {}
  }
  Function {quit(void)} {} {
    code DBG_PROG_START {}
    code {/*Fl::remove_timeout((void (*)(void *))timeIT, (void *)viewer);
  delete viewer;
  delete browser;
  delete canvas;*/
  details->hide();
  icc_examin->quit();} {}
    code DBG_PROG_ENDE {}
  }
  Function {zeig_mich_(void* widget)} {} {
    code DBG_PROG_START {}
    code {// zeigt das ausgewählte Fenster (widget)

  mft_viewer->hide();
  mft_text->hide();
  tag_viewer->hide(); DBG_PROG
  tag_viewer->clear_visible(); DBG_PROG
  tag_text->hide();
  inspekt_html->hide();

  // stop
  if (widget != mft_gl) {
    mft_gl->stop();
    mft_gl->verstecken();
  }
  if (widget != DD_histogram ) {
    DD_histogram->stop();
    DD_histogram->verstecken();
  }

  // start
  if( widget == inspekt_html )
  { DBG_PROG_S("inspekt_html behandeln")
    if( menueintrag_inspekt->value() )
      inspekt_html->show();
    else
      inspekt_html->hide();
  }

  if (widget != mft_gl &&
      widget != DD_histogram )
  { 
    ((Fl_Widget*)widget)->show(); DBG_PROG
    if( !menueintrag_inspekt->value() &&
        !menueintrag_3D->value() )
      ;//selectItem(icc_examin->tag_nr()+6);
  } else if (widget == mft_gl) {
    DBG_PROG_S( "mft GL Fenster belassen." )
    mft_gl->zeigen();
  } else if (widget == DD_histogram) {
    DBG_PROG_S( "3D GL Fenster belassen." )
    DD_histogram->zeigen();
  }} {}
    code DBG_PROG_ENDE {}
  }
  Function {measurement(bool has_measurement)} {} {
    code {if (has_measurement) {
    DBG_PROG_S(menueintrag_inspekt->value())
    if (menueintrag_inspekt->value()) {
      inspekt_html->value(profile.profil()->report().c_str());
      if (inspekt_html->size() -75 < tag_text->inspekt_topline)
        inspekt_html->topline (inspekt_html->size() - 75);
      else
        inspekt_html->topline (tag_text->inspekt_topline);
      //inspekt->show();
      //examin->hide();
    }
    menueintrag_inspekt->activate();
    menueintrag_html_speichern->activate();
  } else {
    menueintrag_inspekt->deactivate();
    menueintrag_html_speichern->deactivate();
    //inspekt->hide();
    //examin->show();
    //menueintrag_inspekt->value( false );
  }} {}
  }
} 

Function {zeilenNachVector(std::string text)} {return_type {std::vector<std::string>}
} {
  code DBG_PROG_START {}
  code {// fügt Zeilen aus einen Text in einen Vector
  std::vector <std::string> texte;

      int len = strlen(text.c_str());
      std::string text_line;
      char c;
      const char *chars = text.c_str();
      for (int zeichen = 0; zeichen < len; zeichen++) {
        c = chars[zeichen];
        if (c == '\\n' || (int)c == 0) { // LF oder 0
          text_line += '\\0';
          texte.push_back(text_line.c_str());
          text_line.clear();
        } else
          text_line += c;
      }
      if (text_line.size() > 0) // falls was übrig bleibt
        texte.push_back(text_line.c_str());

  DBG_PROG_ENDE
  return texte;} {}
} 

Function {dHaendler(void* o)} {return_type {static void}
} {
  code DBG_PROG_START {}
  code {Fl::remove_timeout( (void(*)(void*))dHaendler, 0 );

  if (!Fl::has_timeout( (void(*)(void*))dHaendler, 0 )
   && ((TagDrawings*)o)->active()
   && ((TagDrawings*)o)->visible_r()
   && ((TagDrawings*)o)->wiederholen)
  {
    ((TagDrawings*)o)->ruhigNeuzeichnen();

    \#ifdef DEBUG
    DBG_PROG_V( ((TagDrawings*)o)->wiederholen )
    \#endif
  }} {}
  code DBG_PROG_ENDE {}
} 
